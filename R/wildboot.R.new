##' Wild Bootstrap for regression model.
##'
##' Calculate several wild bootstrapped quantities.
##' 
##' @title wildboot
##' @param x an object
##' @param ... other arguments
##' @return A list with several components
##' @rdname wildboot
##' @author Giuseppe Ragusa
##' @export
wildboot <- function(x, ...)
    UseMethod('wildboot')

##' @rdnames wildboot
##' @method wildboot
##' @S3method wildboot reg
##' @return \code{NULL}
##' @export
wildboot.reg <- function(obj, reps=999, null, 
                         type = c('radamacher', 'mtp', 'mn1', 'mn2'),
                         vcov = c('HC1', 'HC2', 'HC3'))
{

    ## null is a list
    ## for example reg(y~x)
    ## null = list(x=0)
    ## means we are testing whether
    ## the coefficient of x is 0
    ## if null is NULL
    ## then look whether
    ## t is a vector of dimension k
    ## t0 is numeric null hypothesis
    ## such that
    ## H_0: t%*%beta = t0
    ## In this case, the wildbootstrap does
    ## not impose the null
    types  <- c('radamacher', 'mtp', 'mn1', 'mn2')
    wbtype <- match.arg(type)
    wbtype <- switch(wbtype,
                     radamacher = 1,
                     mtp        = 2,
                     mn1        = 3,
                     mn2        = 4)
    vcov <- match.arg(vcov)
    z   <- obj
    y   <- z$model[[1]]
    X   <- model.matrix(z)
    b   <- coef(z)
    w   <- weights(z)
    n   <- length(y)
    k   <- ncol(X)
    r   <- residuals(z) 

    p <- z$rank    
    R <- chol2inv(z$qr$qr[1:p, 1:p, drop = FALSE])

    if(is.null(w))
        w <- rep(1, n)

    y <- y*sqrt(w)
    X <- X*c(sqrt(w))

    if(missing(null))
        stop("'null' is missing")

    if(!is.list(null))
        stop("'null' must be a list")
    ## Check null hypthesis        
    tmp    <- match(names(null), names(b), nomatch = NA)
    if(all(is.na(tmp))) {
        stop("'null' not defined properly")
    } else {
        wr     <- na.omit(tmp)[1]
        null   <- unlist(null)[1]   ## Null hypothesis
    }
    
    if(!is.null(z$cluster)) {
        cluster <- as.factor(z$cluster)
        j <- order(cluster)
        clus.size <- table(cluster)
        clus.start <- c(1, 1 + cumsum(clus.size))
        nc <- length(levels(cluster))
        X <- X[j, , drop = FALSE]
        y <- y[j]
        clus.start <- clus.start[-(nc + 1)]        
    } else {
        nc <- 1
        clus.start <- c(1,n)
        clus.size <- c(n)
        fcl <- 1
    }    
    reps <- ceiling(reps)


    ## H0 Imposed

    ## Calculate beta_restricted and u_restricted
    yr  <- y-X[, wr, drop = FALSE]%*%null
    Xr  <- X[, -wr, drop = FALSE]
    br0 <- solve(crossprod(Xr), crossprod(Xr, yr)) ## this is ((k-1) x 1)
    Ur  <- yr-Xr%*%br0                              ## Restricted residuals
    br  <- rep(null, k)
    br[wr] <- null
    br[-wr] <- br0
    Yhat <- X%*%br
    
    weighting <- switch(wbtype,
                        radamacher = function() {
                            ww <- runif(nc)
                            ww <- ifelse(ww<0.5,-1, 1)
                            out <- NULL
                            for(j in 1:length(ww)) out <- c(out, rep(ww[j], clus.size[j]))
                            out
                        },
                        mtp = function() {
                            ww <- runif(nc)
                            ww <- ifelse(ww<tpp,tp1, tp2)
                            out <- NULL
                            for(j in 1:length(ww)) out <- c(out, rep(ww[j], clus.size[j]))
                            out
                        },
                        mn1 = function() {
                            ww <- rnorm(nc)
                            ww <- ww/sqrt(2)+(ww^2-1)/2
                            out <- NULL
                            for(j in 1:length(ww)) out <- c(out, rep(ww[j], clus.size[j]))
                            out
                        },
                        mn2 = function() {
                            ww <- (delta1+rnorm(nc)/sqrt(2))*(delta2+rnorm(nc)/sqrt(2))-delta1*delta2
                            out <- NULL
                            for(j in 1:length(ww)) out <- c(out, rep(ww[j], clus.size[j]))
                            out
                        })

    coef.wb0 <- se.wb0<- matrix(0, reps, k)

    for(j in 1:reps) {
        Us <- weighting()*c(r)
        Ys <- Yhat+Us
        betas <- solve(crossprod(X), crossprod(X, Ys))
        Us <- Ys-X%*%betas

        res <- switch(EXPR = vcov,                       
                      HC2 = .Call("resHC2", X, Us, R, clus.start, clus.size, PACKAGE="grpack"),
                      HC3 = .Call("resHC3", X, Us, R, clus.start, clus.size, PACKAGE="grpack"),
                      sqrt(((n-1)/(n-k))*(nc/(nc-1)))*Us
                      )
        score <- X*c(res)

        clus.start <- clus.start[-(nc + 1)]
        storage.mode(clus.start) <- "integer"
        ##storage.mode(score) <- "double"
        sp <- k
        W <- matrix(
                    .Fortran("robcovf", n, sp, nc, clus.start, clus.size, 
                             score, double(sp), double(sp * sp), w = double(sp * sp),
                             PACKAGE = "grpack")$w, nrow = sp)

        V <- R%*%W%*%t(R)

        coef.wb0[j,] <- betas
        se.wb0[j,] <- sqrt(diag(V))
    }

    list(coef = coef.wb0, se = se.wb0)
        
}

##' @export
wildbootreg <- function(obj, reps, null,
                         type = c('radamacher', 'mtp', 'mn1', 'mn2'))
{
    wbtype <- match.arg(type)
    wtyp <- switch(wbtype,
                   radamacher = 1,
                   mtp        = 2,
                   mn1        = 3,
                   mn2        = 4)
    z   <- obj
    y   <- z$model[[1]]
    X   <- model.matrix(z)
    b   <- coef(z)
    n   <- NROW(y)
    k   <- NCOL(X)
    wr  <- 1:k
    w   <- weights(z)

    p <- z$rank    
    R <- chol2inv(z$qr$qr[1:p, 1:p, drop = FALSE])
    
    if(is.null(w))
        w <- rep(1, n)
    w <- n*w/sum(w)
    res <- residuals(z)
    
    if(missing(null) | !is.list(null))
        stop('Null must be a list')
    
    if(is.list(null)) {
        tmp  <- match(names(b), names(null), nomatch = NA)
        null <- unlist(null)[tmp]
        wr   <- which(!is.na(tmp))
    }
    
    lwr <- sum(!is.na(wr))
    
    if(missing(reps))
        stop('reps must be an integer > 0')

    reps <- ceiling(reps)
    
    if(!is.null(z$cluster)) {
        cluster <- as.factor(z$cluster)
        j <- order(cluster)
        clus.size <- table(cluster)
        clus.start <- c(1, 1 + cumsum(clus.size))
        nc <- length(levels(cluster))
        X <- X[j, , drop = FALSE]
        y <- y[j]
        w <- w[j]
        clus.start <- clus.start[-(nc + 1)]
        fcl <- (nc/(nc-1))
    } else {
        nc <- 1
        clus.start <- c(1,n)
        clus.size <- c(n)
        fcl <- 1
    }
    
    if(!is.null(w)) {
        X      <- X*c(sqrt(w))
        y      <- y*c(sqrt(w)) 
    }

    factor <- sqrt(((n-1)/(n-k))*fcl)
        
    ## Containers
    # These contains the t-test based on imposing the
    # null hypothesis using a) serr.wb, and b) the
    # se obtained by sd(coef.wb)
    tstat0 <- tstat0.se  <- matrix(0, reps, lwr)
    # These contains the t-test without imposing the
    # null hypothesis using a) serr.wb and b) the
    # seerr obtained by sd(coef.wb)
    tstat  <- tstat.se    <- matrix(0, reps, k)
    
    storage.mode(wtyp)       <- "integer"
    storage.mode(clus.start) <- "integer"
    storage.mode(clus.size)  <- "integer"
    storage.mode(nc)         <- "integer"
    storage.mode(n)          <- "integer"
    storage.mode(k)          <- "integer"
    storage.mode(reps)       <- "integer"
    storage.mode(tmp)        <- "integer"
    storage.mode(lwr)        <- "integer"
    storage.mode(b)          <- "double"
    storage.mode(factor)     <- "double"
    storage.mode(X)          <- "double"
    storage.mode(y)          <- "double"
    storage.mode(res)        <- "double"
    
    for(j in 1:lwr) {
        tmp <- wr[j]
        yr  <- y-X[, tmp, drop = FALSE]%*%null[[tmp]]
        Xr  <- X[, -tmp, drop = FALSE]
        br  <- solve(crossprod(Xr), crossprod(Xr, yr))
        ur  <- yr-Xr%*%br 
        kr  <- ncol(Xr)
        brs <- rep(0,k)
        brs[tmp] <- null[tmp]
        brs[-tmp] <- br

        storage.mode(brs) <- "double"
        storage.mode(ur)  <- "double"
        storage.mode(ur)  <- "double"
        
        out <- .C('wildbootr', X, y, ur, brs, factor, tmp, lwr, n, k,
                  reps, clus.start, clus.size, nc, wtyp,
                  coef.wb = double(reps), serr.wb = double(reps))
        
        coef.wb0        <- out$coef.wb
        serr.wb0        <- out$serr.wb
        names(coef.wb0) <- names(b)[tmp]
        tstat0[,j]      <- (coef.wb0 - null[tmp])/serr.wb0
        tstat0.se[,j]   <- (coef.wb0 - null[tmp])/sd(coef.wb0)
    }
    
    nul <- unlist(null)
    nul[is.na(nul)] <- 0
    tstat0.se <- (b[wr]-nul[wr])/sd(coef.wb0)
    ## Do the unconstrained

    out <- .C('wildbootr', X, y, res, b, factor, as.integer(0), k,
              n, k, reps, clus.start, clus.size, nc, wtyp,
              coef.wb = double(reps*k), serr.wb = double(reps*k))

    coef.wb <- matrix(out$coef.wb, nrow = reps, ncol = k)
    serr.wb <- matrix(out$serr.wb, nrow = reps, ncol = k)
    colnames(coef.wb) <- names(b)
    tms <- sd(coef.wb)    
    for(j in 1:k) {
        tmp <- (coef.wb[,j] - b[j])
        tstat[,j]    <- tmp/serr.wb[,j]
    }

    tstat.se         <- (b-nul)/tms 
    obj$coef.wb      <- coef.wb        ## reps x k
    obj$se.wb        <- serr.wb        ## reps x k
    obj$coef.wb0     <- coef.wb0       ## reps x lwr
    obj$se.wb0       <- serr.wb0       ## reps x lwr
    obj$tstat        <- tstat          ## reps x k
    obj$tstat0       <- tstat0         ## reps x lwr
    obj$tstat.se     <- tstat.se       ## k x 1
    obj$tstat0.se    <- tstat0.se      ## lwr x 1
    obj$null         <- null           ## lwr x 1
    obj$wr           <- wr             ## k x 1 (NA non restricted)
    obj$lwr          <- lwr
    obj$se.wb.sd     <- tms            ## k x 1
    obj$reps         <- reps           ## # of replications
    obj$distr        <- 'em_a'         ## Only this right now
    class(obj)       <- c("reg.wb", class(obj))
    obj$model        <- NULL
    obj$nc           <- nc
    obj
}
##' @S3method print reg.wb
print.reg.wb <- function(x, ...) {
    print.reg(x)
    cat('Wild bootstrap:\n')
    cat('\n')
    cat(' # reps: ', x$reps, '; distr: ', x$distr, sep = '')
    if(!is.null(x$cluster))
        cat('; cluster:', x$clusterby)
    if(!is.null(x$weights))
        cat('; weighted:', x$weightedby)
    cat('\n\n')
        
    cat('Null hypotheses:\n')
    for(j in na.omit(x$wr))
        cat('', names(x$null)[j], ' = ', x$null[[j]], '\n')
    cat('\n')
}

##' @S3method summary reg.wb
summary.reg.wb <- function(x, vcov = "HC3", ...) {
    b  <- coef(x)
    se <- sqrt(diag(vcov(x, type = vcov)))
    h0 <- unlist(x$null)
    h0[is.na(h0)] <- 0
    tstat <- (b-h0)/se
    pv0 <- matrix(0, 2, x$lwr)
    pv  <- matrix(0, 2, length(b))

    for(j in 1:length(b)) {
        ats <- abs(tstat[j])
        edf3 <- ecdf(x$tstat[,j])
        pv[1,j] <- edf3(-abs(ats))+(1-edf3(abs(ats)))
    }
    pv[2,] <- 2*pnorm(-abs(x$tstat.se))
        
    for(j in 1:x$lwr)
    {   ts <- abs(tstat[x$wr[j]])
        edf3 <- ecdf(x$tstat0[,j])
        pv0[1,j] <- edf3(-ats)+(1-edf3(ats))
    }
    pv0[2,] <- 2*pnorm(-abs(x$tstat0.se))
    
    out              <-  x
    out$pv.tstat0.se <-  pv0[2,]
    out$pv.tstat.se  <-  pv[2,]
    out$pv.tstat     <-  pv[1,]
    out$pv.tstat0    <-  pv0[1,]
    if(!is.null(x$cluster) & x$nc>2) {
        out$pv.tstat.se.t  <- 2*pt(-abs(x$tstat.se),  df = x$nc-2)
        out$pv.tstat0.se.t <- 2*pt(-abs(x$tstat0.se), df = x$nc-2)
    }
    class(out) <- c('summary.reg.wb', class(x))
    out
}

##' @S3method print summary.reg.wb
print.summary.reg.wb <- function(x, digits = max(3, getOption("digits") - 3), ...) {
    b <- coef(x)
    nb <- names(b)
    k <- length(b)
    cat('\nNull Hypothesis:')
    for(j in 1:k) {
        cat('\n ', nb[j], ' = ', x$null[j], '\n')
        cat(' wb p-value (a):' , format.pval(x$pv.tstat0[j]),
            symnum(x$pv.tstat0[j], corr = FALSE, na = FALSE, 
                   cutpoints = c(0, 0.01, 0.05, 0.1, 1), 
                   symbols = c("***", "**", "*", " ")), '\n')
        cat(' wb p-value (b):' , format.pval(x$pv.tstat0.se[j]),
            symnum(x$pv.tstat0.se[j], corr = FALSE, na = FALSE, 
                   cutpoints = c(0,  0.01, 0.05, 0.1, 1), 
                   symbols = c("***", "**", "*",  " ")), '\n')
        cat(' wb p-value (c):' , format.pval(x$pv.tstat[j]),
            symnum(x$pv.tstat[j], corr = FALSE, na = FALSE, 
                   cutpoints = c(0, 0.01, 0.05, 0.1, 1), 
                   symbols = c("***", "**", "*", " ")), '\n')
        cat(' wb p-value (d):' , format.pval(x$pv.tstat.se[j]),
            symnum(x$pv.tstat.se[j], corr = FALSE, na = FALSE, 
                   cutpoints = c(0, 0.01, 0.05, 0.1, 1), 
                   symbols = c("***", "**", "*",  " ")), '\n')
    }

    cat("\n ---\n Signif. codes: '***' 0.01 '**' 0.05 '*' 0.1  \n")
}


##' @export
wildboot.reg2 <- function(object, sim = 999, null = list(),
                          type = c('radamacher', 'mtp', 'mn1','mn2'),
                          vcov = c('HC1', 'HC2', 'HC3'))
{
    type <- match.arg(type)
    vcov <- match.arg(vcov)
    ## Null hypothesis is a list
    ## naming names
    if(!is.list(null) || length(null)>1)
        stop('null must be a list of max length 1')
    mf <- model.frame(object)
    y <- mf[,1]
    X <- model.matrix(object)
    betahat <- coef(object)
    sehat <- sqrt(diag(vcov(object)))
    nv <- names(betahat)
    rr <- object
    whr <- NA
    if(length(null)>0)
    {
        form <- paste(object$term[[2]], '~ 1')
        for(j in 1:length(nv))
        {
            if(nv[j]==names(null))
            {
                offset = null[[1]]*mf[[nv[j]]]
                whr <- j
            }
            else
                if(nv[j]!='(Intercept)')
                    form <- paste(form, nv[j], sep = '+') 
        }
        formula <- as.formula(form)
        rr$call[[2]] <- form
        rr$call$offset <- offset
        rr <-  eval(rr$call, envir = attributes(rr$terms)$.Environment)
    }
    se <- sqrt(diag(vcov(rr)))
    Yhat <- predict(rr)
    r <- residuals(rr)
    
    cluster <- as.factor(rr$cluster)
    j <- order(cluster)
    clus.size <- table(cluster)
    clus.start <- c(1, 1 + cumsum(clus.size))
    nc <- length(levels(cluster))
    clus.start <- clus.start[-(nc + 1)]
    storage.mode(clus.start) <- "integer"
    p <- object$rank
    n <- NROW(object$qr$qr)
    w <- object$weights
    sp <- p
    R <- chol2inv(object$qr$qr[1:p, 1:p, drop = FALSE])
    if(!is.null(w))
        factor <- sqrt((sum(w)-1)/(sum(w)-p) * nc/(nc-1))
    else
        factor <- sqrt((n-1)/(n-p) * nc/(nc-1))
    X <- X[j, , drop = FALSE]
    y <- y[j]
    rr <- r[j]
    
    out <- matrix(0, sim, 2*p)
    ## weighting constants
    tp1 <- -(sqrt(5)-1)/2
    tp2 <- (sqrt(5)+1)/2
    tpp <- (sqrt(5)+1)/(2*sqrt(5))
    delta1 <- (3/4+sqrt(17)/12)^.5
    delta2 <- (3/4-sqrt(17)/12)^.5

    mr2 <- function() {
        res <- NULL
        for (jj in 1:nc) {
            ind   <- clus.start[jj]+ (0:(clus.size[jj]-1)) 
            Xi    <- X[ind,,drop=FALSE]
            Hgg   <- chol(diag(length(ind))-Xi%*%R%*%t(Xi), pivot = TRUE)
            pivot <- attr(Hgg, "pivot")
            oo    <- order(pivot)
            Hgg   <- Hgg[,oo]
            res   <- c(res, solve(Hgg)%*%r[ind])
        }
        res
    }
    
    mr3 <- function() {
        res <- NULL
        for (jj in 1:nc) {
            ind <- clus.start[jj]+ (0:(clus.size[jj]-1)) 
            Xi  <- X[ind,,drop=FALSE]
            Hgg <- solve(diag(length(ind))-Xi%*%R%*% t(Xi))
            res <- c(res, Hgg%*%r[ind])
        }
        sqrt((nc-1)/nc)*res
    }
    
    for(j in 1:sim)
    {
        wr <- wbwf()*c(rr)
        yw <- Yhat+wr
        betaw <- solve(crossprod(X), crossprod(X, yw))
        r <- c(yw-X%*%betaw)
        res <- switch(EXPR = vcov,                       
                      HC2 = mr2(),
                      HC3 = mr3(),
                      factor*r
                      )

        score <- X*c(res)
        W <- matrix(
                    .Fortran("robcovf", n, sp, nc, clus.start, clus.size, 
                             score, double(sp), double(sp * sp), w = double(sp * sp),
                             PACKAGE = "grpack")$w, nrow = sp)
        se <- sqrt(diag(R%*%W%*%t(R)))
        out[j,] <- c(betaw, se)
    }
    
    ans <- list(coef.wb = out[,1:p], se.wb = out[,(p+1):(2*p)])
    colnames(ans$boot.coef) <- rownames(betahat)
    colnames(ans$ses) <- rownames(betahat)
    
    ans$lm.full <- object
    ans$lm.restricted <- rr
    ans$coef <- betahat
    ans$se <- sehat
    attr(ans, 'clus.size') <- clus.size
    attr(ans, 'clus.start') <- clus.start
    attr(ans, 'which.restricted') <- whr
    attr(ans,'restrictions') <- null
    attr(ans,'p') <- p
    class(ans) <- 'wildboot'
    ans
}
